/*
프로그래머스
SQL ORACLE leve3-2

풀이 순서, 정답률 높은 순

*/






---- 대여 기록이 존재하는 자동차 리스트 구하기
/* 
조건
    자동차 종류가 '세단'인 자동차들 중 10월에 대여를 시작한 기록이 있는 자동차 ID 리스트를 출력 
    1)종류 세단
    2)10월 대여
    3)자동차 ID 리스트는 중복x
    4)자동차 ID를 기준으로 내림차순 
    
brainstorming
    1)종류 세단 : WHERE OR HAVING A.CAR_TYPE = '세단'
    2)10월 대여 : WHERE OR HAVING EXTRACT(MONTH FROM B.START_DATE) = 10
    3)자동차 ID 리스트는 중복x : GROUP BY

*/


-- 1.종류 세단 : WHERE A.CAR_TYPE = '세단'
-- SELECT A.CAR_ID, CAR_TYPE
-- FROM CAR_RENTAL_COMPANY_CAR A
--     JOIN CAR_RENTAL_COMPANY_RENTAL_HISTORY B ON A.CAR_ID = B.CAR_ID
-- WHERE A.CAR_TYPE = '세단'
-- ORDER BY A.CAR_ID DESC


-- 2. 10월 대여 시작 : HAVING EXTRACT(MONTH FROM B.START_DATE) = 10
-- SELECT A.CAR_ID--, CAR_TYPE
-- FROM CAR_RENTAL_COMPANY_CAR A
--     JOIN CAR_RENTAL_COMPANY_RENTAL_HISTORY B ON A.CAR_ID = B.CAR_ID
-- WHERE A.CAR_TYPE = '세단'
-- GROUP BY A.CAR_ID,B.START_DATE -- 자동자ID중복X 조건?
-- HAVING EXTRACT(MONTH FROM B.START_DATE) = 10
-- ORDER BY A.CAR_ID DESC
-- -- CAR_ID 중복됨 -> HAVING 때문에 GROUP BY에 START_DATE를 추가해야하므로 WHERE문으로 변경

-- SELECT A.CAR_ID--, CAR_TYPE
-- FROM CAR_RENTAL_COMPANY_CAR A
--     JOIN CAR_RENTAL_COMPANY_RENTAL_HISTORY B ON A.CAR_ID = B.CAR_ID
-- WHERE A.CAR_TYPE = '세단'
--     AND EXTRACT(MONTH FROM B.START_DATE) = 10
-- GROUP BY A.CAR_ID
-- ORDER BY A.CAR_ID DESC


-- 정답1 : WHERE + EXTRACT + GROUP BY
 SELECT A.CAR_ID
 FROM CAR_RENTAL_COMPANY_CAR A
     JOIN CAR_RENTAL_COMPANY_RENTAL_HISTORY B ON A.CAR_ID = B.CAR_ID
 WHERE A.CAR_TYPE = '세단'
     AND EXTRACT(MONTH FROM B.START_DATE) = 10
 GROUP BY A.CAR_ID
 ORDER BY A.CAR_ID DESC

-- 정답2 : DISTINCT + WHERE + TO_CHAR()
SELECT DISTINCT A.CAR_ID
FROM CAR_RENTAL_COMPANY_CAR A, CAR_RENTAL_COMPANY_RENTAL_HISTORY B
WHERE A.CAR_ID = B.CAR_ID
    AND A.CAR_TYPE = '세단' 
    AND TO_CHAR(B.START_DATE, 'YYYYMM') = '202210' 
ORDER BY 1 DESC;












---- 없어진 기록 찾기
/* 
조건
    데이터가 유실됨. 입양을 간 기록은 있는데, 보호소에 들어온 기록이 없는 동물 조회
    1)입양기록O, 보호소 IN기록X
    2)
    
brainstorming
    1)입양기록O : B.DATETIME NOT NULL || NVL, IS NULL, NULLIF
        WHERE B.DATETIME IS NOT NULL
    2)보호소IN기록X : A.DATETIME NULL 
        WHERE A.DATETIME IS NULL
    3)한쪽에만 있는 데이터도 나와야하기 때문에 FULL JOIN
        입양기록O,보호소기록X면 LEFT,RIGHT를 써야하나...?
    4)ANIMAL_INS에 없으므로 라는 말을 보면 ANIMAL_OUTS B 기준으로 봐야할 듯?
    
*/

-- SELECT A.ANIMAL_ID, A.NAME
-- FROM ANIMAL_INS A
--     JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID

-- -- 1.입양간 기록O,보호소기록X 조건 추가 : WHERE A.DATETIME IS NULL AND B.DATETIME IS NOT NULL
-- SELECT A.ANIMAL_ID, A.NAME
-- FROM ANIMAL_INS A
--     FULL OUTER JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID
-- WHERE A.DATETIME IS NULL 
--     AND B.DATETIME IS NOT NULL
-- ORDER BY A.ANIMAL_ID, A.NAME

-- 혹시 몰라서 B테이블도 조회해봄 : 내용X
-- SELECT B.ANIMAL_ID, B.NAME
-- FROM ANIMAL_INS A
--     FULL OUTER JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID
-- HERE A.DATETIME IS NULL 
--     AND B.DATETIME IS NOT NULL
-- ORDER BY B.ANIMAL_ID, B.NAME


-- 뭘해야할지 모르겠으니 일단 다시한번 하나씩 쪼개서 조회해보자
-- SELECT A.ANIMAL_ID, A.DATETIME, B.ANIMAL_ID, B.DATETIME
-- FROM ANIMAL_INS A
--     FULL JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID
-- -- 각각 한쪽에만 있는 동물들이 있음. A만 있으면 입양아직인거고, B에만 있으면 데이터유실임


-- 예제 "Allie의 ID는 ANIMAL_INS에 없으므로, Allie의 데이터는 유실되었습니다"로 만들어봄
-- SELECT A.ANIMAL_ID, A.DATETIME, B.ANIMAL_ID, B.DATETIME
-- FROM ANIMAL_INS A
--     FULL JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID
-- WHERE B.DATETIME IS NOT NULL    
--     AND A.DATETIME IS NULL
-- ORDER BY B.ANIMAL_ID, B.NAME
    
-- 예제보면 'ANIMAL_INS에 없으므로'의 말로보아 ANIMAL_OUTS B 기준으로 봐야할 듯  
-- SELECT B.ANIMAL_ID, B.NAME
-- FROM ANIMAL_INS A
--     FULL JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID
-- WHERE B.DATETIME IS NOT NULL    
--     AND A.DATETIME IS NULL
-- ORDER BY B.ANIMAL_ID, B.NAME


-- 정답1 : FULL JOIN + IS NULL + IS NOT NULL
SELECT B.ANIMAL_ID, B.NAME
FROM ANIMAL_INS A
    FULL JOIN ANIMAL_OUTS B ON A.ANIMAL_ID = B.ANIMAL_ID
WHERE B.DATETIME IS NOT NULL    
    AND A.DATETIME IS NULL
ORDER BY B.ANIMAL_ID, B.NAME

-- 정답2 : RIGHT JOIN + IS NULL (리소스 덜 잡아먹는 쿼리)
SELECT B.ANIMAL_ID, B.NAME
FROM ANIMAL_INS A, ANIMAL_OUTS B
WHERE A.ANIMAL_ID (+) = B.ANIMAL_ID
   AND A.ANIMAL_ID IS NULL
ORDER BY B.ANIMAL_ID


-- 정답3 : SUBQUERY + NOT EXISTS
SELECT ANIMAL_ID, NAME 
FROM ANIMAL_OUTS AO
WHERE NOT EXISTS (
    SELECT 1 
    FROM ANIMAL_INS AI 
    WHERE AI.ANIMAL_ID = AO.ANIMAL_ID
    )
ORDER BY ANIMAL_ID














---- TITLE
/* 
조건
    2022년 10월 5일에 등록된 중고거래 게시물 조회
    1)
    2)
    
brainstorming
    1)
    2)

*/


-- 1.
-- 2.
-- 3.

-- 정답1 : 
-- 정답2 : 




/*
다시 풀어 볼 문제

     1.



*/





